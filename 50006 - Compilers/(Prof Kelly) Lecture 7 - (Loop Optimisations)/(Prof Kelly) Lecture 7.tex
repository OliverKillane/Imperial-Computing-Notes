\documentclass{report}
    \title{50006 - Compilers - (Prof Kelly) Lecture 7}
    \author{Oliver Killane}
    \date{15/04/22}
\input{../50006 common.tex}
\begin{document}
\maketitle

\section*{Loop Invariant Code Motion}
\lectlink{https://imperial.cloud.panopto.eu/Panopto/Pages/Viewer.aspx?id=4706c2d0-9388-4231-ae8d-ae140101738c}
\termdef{Loop Invariant}{
	An instruction is \keyword{loop-invariant} if its operands are only defined outside of the loop. Hence the value it defines is not loop-invariant (same for every iteration) and hence it may be possible to move the instruction outside the loop.
	\centerimage{width=0.9\textwidth}{loop invariant code}
}
\subsection*{Finding Loop-Invariant Instructions}
Using a control flow graph, each node is an instruction. We attempt to find definition nodes of form:
\[\underbrace{d}_\text{Node ID} : \ t_d := ( \underbrace{u_1 \ \bullet \ u_2}_\text{Binary Op}  \ | \ \underbrace{u_1}_\text{Copy Op} \ | \ \underbrace{c}_\text{Constant})\]
Where $t_d$ is the destination, and $u_i$ is for temporary variables used.
\\
\\ $d$ is \keyword{loop-invariant} if every definition of a $u_i \in uses(d)$ that reaches $d$ is outside the loop.
\example{Basic Loop}{
	We can see in this loop that some definitions are used as operands. Including from previous iterations of the loop.
	\centerimage{width=0.5\textwidth}{example loop}
}
\sidenote{Definitions}{
	We refer to a node/instruction defining some variable $t$ as a definition of $t$.
}
\termdef{Reach}{
	A \keyword{definition} $d$ reaches $p$ if there is a path from $d \to p$ where $d$ is not killed.
	\centerimage{width=0.5\textwidth}{reach}
	For a node $n$ we have several sets containing other nodes/instructions:
	\[\begin{split}
			Gen(n) &= \{n\} = \text{the set of definitions generated by the node} \\
			Kill(n) &= \text{Set of all definitions of $t$ except for $n$} \\
			ReachIn(n) &= \text{Set of definitions reaching up to $n$} \\
			ReachOut(n) &= \text{Set of definitions reaching after $n$} \\
		\end{split}\]
}
We can calculate the \keyword{reach-in} and \keyword{reach-out} sets as:
\[\begin{split}
		ReachIn(n) &\triangleq \bigcup_{p \in Pred(n)}ReachOut(p) \\
		ReachOut(n) &\triangleq Gen(n) \cup (ReachIn(n) \setminus Kill(n)) \\
	\end{split}\]
This is a \keyword{forward analysis} as definitions reach forwards.
\codelist{Python}{reaching sets.py}
Form the \keyword{reaching definitions}, we can reduce each set to the \keyword{relevant reaching definitions}, by considering only the reachins that are actually used by the instruction (for operands).
\example{Basic Reaching Definitions}{
	\centerimage{width=0.7\textwidth}{example reach}
}

\subsection*{Identifying Loops}
\termdef{Loop}{
	Given a set $S$ of nodes that are part of a loop.
	\compitem{
		\item There is a single header node $h \in S$.
		\item There is a path from $h$ to any other node in $S$.
		\item There is a path from any node in $S$ to $h$.
		\item All non-loop nodes can only directly connect to the header $h$, and no other nodes in the loop.
	}
	\centerimage{width=0.6\textwidth}{loop structure}
}
\termdef{Dominator}{
	Node $d$ dominates node $n$ if every path from the start node to $n$ goes through $d$ (Note that every Node dominates itself).
	\\
	\\ Hence for each node we can get the set of nodes it \keyword{dominates} (as shown below), or the set of nodes that \keyword{dominate} it.
	\centerimage{width=0.9\textwidth}{dominate example}
}

To find all the nodes that \keyword{dominate} a given node:
\compenum{
	\item Set all $Dom$ sets to the set of all nodes.
	\item Apply the rules (as below), as the start node will have a set of $\{start\}$ this will propagate, reducing the sizes of the sets for other nodes.
	\item Once the sets stop changing, we have our solution.
}
\centerimage{width=0.9\textwidth}{finding dominator}
\termdef{Back Edges}{
	An edge in the \keyword{control flow graph} from $n \to h$, where $h$ dominates $n$ is a \keyword{back edge}.
	\centerimage{width=0.8\textwidth}{back edge}
}
\termdef{Natural Loop}{
	The \keyword{natural loop} of a \keyword{back-edge} $(n,h)$ is the set of nodes $S$ such that:
	\compitem{
		\item All nodes $x \in S$ are dominated by $h$
		\item For all nodes $x \in S$ (except $h$), there is a path from $x \to n$ that does not contain $h$.
	}
	This represents a loop, with the header node $h$.
}

\subsection*{Multiple Loops}
\centerimage{width=0.9\textwidth}{intersecting natural loops}
\termdef{Control Tree}{
	We can construt a tree to show which loops are nested, what the headers and final nodes in each loop are.
	\centerimage{width=0.9\textwidth}{control tree}
}

\subsection*{Hoisting Instructions}
\termdef{Pre-Header}{
	A node inserted immediately before the \keyword{header} node of a \keyword{natural loop}.
	\centerimage{width=0.9\textwidth}{pre header}
}
\lectlink{https://imperial.cloud.panopto.eu/Panopto/Pages/Viewer.aspx?id=89b65be5-c7c6-4e99-8d95-ae140101d039}
Consider the following examples:
\centerimage{scale = 0.2}{hoisting examples/A}
\centerimage{scale = 0.2}{hoisting examples/B}
\halfsplit{
	\centerimage{scale = 0.15}{hoisting examples/C}
}{
	\centerimage{scale = 0.15}{hoisting examples/D}
}
Given a node $d: \ t = a \bullet b$ the conditions for hoisting are:
\compenum{
	\bullpara{All reaching definitions used by $d$ occur outside the loop}{
		\\ We must not use data defined inside the loop (otherwise not invariant). Use \keyword{reaching definition} analysis for this.
	}
	\bullpara{Loop invariant node must dominate all loop exits}{
		\\ The pre-header dominates all exits, hence in order to be moved to the pre-header, the invariant node must also. Use \keyword{dominators} analysis for this.
	}
	\bullpara{There can only be one definition of $t$}{\\ Count the definitions.}
	\bullpara{$t$ cannot be liveout from the loop's pre-header}{
		\\ If $t$ is live out from the pre-header, it means that $t$ is used somewhere in the loop ($t$ is also defined in the loop), or the value of $t$ from the pre-header is used after the loop (e.g a while loop when no iterations are run). Hence we cannot hoist it.
		Use \keyword{live range} analysis for this.
	}
}


The basic process of hoisting loop-invariant instructions out of a loop is:
\compenum{
	\item Compute \keyword{dominance} sets for each node.
	\item Use \keyword{dominance} sets to identify natural loop and their headers.
	\item Compute the reaching sets for nodes.
	\item Use relevant reaching definitions to identify loop-invariant code.
	\item Attempt the loop invariant code to a \keyword{pre-header}.
	\item Check that the semantics of the program are not altered.
}
This process can potentially be repeated (e.g hoisting out of several layers of nested loops).

\section*{Static Single Assignment}
\lectlink{https://imperial.cloud.panopto.eu/Panopto/Pages/Viewer.aspx?id=89b65be5-c7c6-4e99-8d95-ae140101d039}
\termdef{Static Single Assignment (SSA)}{
	A representation avoiding side conditions by allowing only a single assignment to each temporary (temporaries are immutable).
	\compitem{
		\item Simplifies many optimisation problems
		\item Requires a potentially complex translation (to and from SSA)
		\item Makes many optimisation passes more efficient.
		\item Widely used in compilers.
	}
	Each Reassignment of a variable is renamed, this splits all live ranges.
	\compitem{
		\item Live ranges split (temporary is live from definition to last use, with no gaps in liveness).
		\item Each variable has only one reaching definition.
	}
	\centerimage{width=0.9\textwidth}{SSA form}
	The \keyword{phi function}  is used for branching. A \keyword{phi} statement $\varphi(a_1, a_2)$ means either $a_1$ or $a_2$ could be used.
	\\
	\\ By renaming variables, we can eliminate many of the loop hoisting issues (particularly for variable redefinitions in the loop)
}

\example{Hoist a node that does not dominate the exit}{
	The renaming done by SSA allows us to move a node so that it dominates the exit (allowing us to hoist it from the loop), without altering the semantics of the program.
	\centerimage{width=\textwidth}{hoisting examples/B SSA}
}
\example{Hoist with multiple definitions of $t$}{
	Again, renaming from SSA allows us to hoist.
	\centerimage{width=\textwidth}{hoisting examples/C SSA}
}
\example{Hoist when $t$ is liveout from the Pre-Header}{
	\centerimage{width=\textwidth}{hoisting examples/D SSA}
}
Once in \keyword{SSA} form, we can reassess the requirements for hoisting:
\compenum{
	\bullpara{All reaching definitions used by $d$ occur outside the loop}{
		\\ (Same as prior to \keyword{SSA}). Use \keyword{reaching definitions} analysis for this.
	}
	\bullpara{Loop invariant node must dominate all loop exits}{
		\\ No longer an issue.
	}
	\bullpara{There can only be one definition of $t$}{\\ Guarenteed by \keyword{SSA} form.}
	\bullpara{$t$ cannot be liveout from the loop's pre-header}{
		\\ Cannot occur with \keyword{SSA} due to single assignment.
	}
}
\section*{Other Compiler Optimisations}
There is a wide selection of optimisation techniques that can be applied, some general (e.g inlining), while others are architecture specific (optimising instruction selection).
\begin{center}
	\begin{tabular}{c c c}
		Induction Variables                                                                                 & Strength Reduction                                                        & Induction variable Elimination \\
		Rewriting Comparisons                                                                               & Array Bounds Check Elimination                                            & Common Sub-Expressions         \\
		\href{https://en.wikipedia.org/wiki/Partial_redundancy_elimination}{Partial Redundance Elimination} & Loop Unrolling                                                            & Inlining                       \\
		Dead Code Elimination                                                                               & \href{https://en.wikipedia.org/wiki/Rematerialization}{Rematerialisation} & Tail-Call Optimisation         \\
	\end{tabular}
\end{center}
While conventional compilers attempt to reduce work to be done at runtime, \keyword{restructuring compilers} determine the optimal order to do a computation (hence re-structuring the computation).
\\
\\ For example adding parallelism to loops, or changing the order nesting of loops (e.g to allow for SMID instructions, or better cache locality).
\subsection*{Higher-Level Optimisations}
Higher level programming language features require care to be optimised.
\compitem{
	\bullpara{Subtype Polymorphism}{
		\\ Given some $x.f()$ we may be able to determine the method called at compile time (allowing inlining, removing loads required to go to $x$'s \keyword{Method Lookup Table}) or be able to inline selection (if statements/switches) to determine what the type is and run code accordingly.
	}
	\bullpara{Pattern Macthing}{
		\\ A feature of languages such as Haskell, Prolog and Rust. Compile should determine the optimal order of tests (that still respects the language semantics - i.e matching order)
	}
	\bullpara{Memory Management}{
		\\ Managing heap/dunamic variables, either not doing management (left to the programmer - C), compiler using programmer provided information (and inferring as in Rust), or garbage collectors at runtime.
	}
	\bullpara{Lazy Evaluation}{
		\\ Moving evaluations of expressions to their uses (so no redundant computation is done), or constructing closures to represent complex computations.
	}
	\bullpara{Arrays}{
		\\ Optimising overloads (e.g $+$ to concatenate arrays), and the underlying structure (e.g determining optimal array/list structure at compile time for the programmer). Allowing for efficient access to arrays containing types (e.g arrays of objects - array of pointers, or array of structs).
		\\
		\\ Allowing array slicing (e.g $A[3..10]$) without requiring lots of copying of data, or restricting usage of the array the slice is taken from.
	}
}
\end{document}
